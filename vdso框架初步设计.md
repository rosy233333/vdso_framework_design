# vdso框架初步设计

时间：2025.4.26

## vdso部分

### 结构

一个放在vdso内部的模块可分为三个部分：代码、局部数据、共享数据。

- 代码：通过编译为cdylib，可以实现代码的位置无关。
- 局部数据：不同地址空间保存一份各自的副本，不相互共享。没有位置无关问题。
- 共享数据：不同地址空间操作同一份数据，这其中的数据需要实现位置无关。

vdso机制的优势就在于共享数据。如果只有代码和局部数据，那就与共享库没有区别。

全局变量和使用`alloc`分配的局部变量既可以声明为局部数据，又可以声明为共享数据。按值存储的局部变量均为局部数据。

框架需要提供局部数据和共享数据的声明机制和实现机制。

目前已实现的内容：基于`get_data_base`的共享数据实现机制；用于共享数据的位置无关的堆分配器、位置无关的指针。

### 依赖

若vdso中的代码依赖外部代码，则有如下几种情况：

- 若依赖其它Rust库的代码：基于Rust的编译机制，将它们静态链接到vdso中即可。
- 若以动态链接的方式依赖C库函数（如`memcpy`、`memmove`）：由于async-os还不支持动态链接，因此可以使用`build-std-features`等机制强制将这些函数改为静态链接（详见[本文档](https://gitee.com/LC_rosy/weekly-progress/blob/master/25.2.17~25.2.26/vdso%E5%85%B1%E4%BA%AB%E8%B0%83%E5%BA%A6%E5%99%A8debug%E6%97%A5%E5%BF%97.md#%E5%85%B3%E4%BA%8E%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7%E7%9A%84bug)）
- 若依赖其它vdso库的内容：目前在不支持动态链接的环境下，还无法做到。因此考虑需要实现动态链接功能，从而使其这种依赖可以实现（这种情况是可能的，需要增加动态链接的支持）
- 若依赖操作系统本身的功能：较难实现，因为vdso中的代码既可能运行在用户空间中，又可能运行在内核空间中。需要尽可能维持用户/内核对vdso的单向依赖==（这种情况应该是：vDSO不直接使用内核的代码，内核自己的代码来修改数据，vDSO 中使用这些数据）==

框架需要支持以上四种依赖方式中的几种（支持哪些还可以再讨论：这四种依赖方式，在实际开发过程中必要性如何？）。

目前已实现的内容：静态链接方式依赖其它Rust库的代码（Rust自身的机制就支持）和静态链接方式依赖libc。

### 调用

vdso库通过将函数放置在全局符号表中，从而支持外部的调用。

## vdso外的部分

### 初始化

负责vdso初始化的模块位于内核，用于将vdso模块加载到内核和用户的地址空间中。

目前该初始化模块已经实现

### 调用vdso函数

这部分模块可被内核或用户依赖，用于简化调用vdso函数的过程。例如，将“获取vdso首地址->解析elf->查找函数->调用特定函数”的过程包装为调用一个函数。

目前我已经实现了这样的调用模块。

## 其它设想

### 与协程的配合

==对于一些简单的耗时不长的功能，没有必要改成 `async` 函数的形式；对于读写文件这类耗时的操作、以及设备驱动等，可以考虑与协程结合；但是直接改造成 `async` 函数应该不是 FFI 安全的，这个问题要考虑；如果只改成 `async` 的形式而没有遇到什么问题的话，可以直接达到这个目标，如果遇到了困难，可能还要考虑与共享调度器的 vDSO 模块结合起来。==

因为async-os支持协程，因此考虑内核/用户对vdso的调用能否支持`async`形式。

根据Rust协程的机制，调用`async`函数实际上是调用了一个返回`Future`的普通函数，而对`Future`进行`await`操作则是将`Future` `pin`在堆上，并调用它的`poll`方法，根据返回值决定协程是继续执行还是让出。

如果直接将vdso的接口函数改为`async`形式，即是让它们返回一个`Future`，由用户或内核来`poll`这个`Future`。由于返回类型不确定，需要返回一个指向`trait object`的指针。而指针指向的内存，只能在vdso内部分配。因为位于同一地址空间，因此进程内可以正常获取返回的`Future`及其`poll`函数。

`Future`可以在局部数据中分配，因此其不涉及位置无关。在`Future`内部，再访问vdso的共享数据。

### 可用于共享数据的锁

==在激进的设计中，内核和用户任务控制块应该是可以统一起来的==

共享数据难以用锁进行保护，因为以下两个原因：

1. 对共享数据的竞争涉及用户态和内核态，而用户态的临界区可以被内核态抢占。即使将用户态任务设置为最高优先级，也需要陷入内核态处理中断。
2. 用户态和内核态的任务控制块不同，导致基于让出的锁难以在用户态和内核态提供统一的让出接口。

问题1目前还未想到解决方案。不过，在共享调度器统一了用户态和内核态的调度后，问题2能够得以解决。

对vdso中用到的所有共享数据均使用无锁同步，实现难度较大。能否解决或绕开以上两个问题，从而实现一种可用于用户态和内核态间共享数据的锁？==（这个可以从论文来找）==

### 使用宏简化开发

可以将一些操作封装成宏，从而降低开发vdso模块与开发一般模块间的难度。例如：

- 对局部数据和共享数据的声明
- 对vdso函数的调用==（这个可以考虑和 `async` 关键字结合起来）==



==需要考虑要达到的目标：这个 vDSO 框架能够取得什么样的性能效果，共享对于代码体积的缩小程度有多少？类似于这些性能指标等？==
