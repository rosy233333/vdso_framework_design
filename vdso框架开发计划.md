# vdso框架开发计划

## 开发目标

尽量减少vdso共享库与一般共享库的差别，减少vdso共享库的功能限制。使得可以使用接近于一般共享库的开发方式开发vdso共享库，并使其在内核态和用户态间共享。

vdso共享库在一般共享库的基础上，额外具备以下的功能：

1. 可被加载到内核态和用户态
2. 有一块不同特权级和地址空间中的vdso代码均可读写的共享数据区域，以实现通信等其它功能

目前的开发目标为以下两点：

- 对于功能1：为AsyncOS的用户态和内核态实现加载共享库机制。
- 对于功能2：为vdso的共享数据实现映射、访问和无锁同步机制。

此外，为了实现功能1，可能还需要实现一些系统功能接口在用户态和内核态的统一（例如，传统的共享库通过系统调用访问内核功能，就无法直接移植到内核）。不过目前的开发计划还未考虑这点。

## 开发计划

（以下步骤按时间顺序排列）

<!-- ### 1. 私有数据相关

调研vdso共享库实现私有数据的方式：是否已经实现？（即，如果直接在vdso共享库中声明可变全局变量，能否作为私有数据正常使用？）若否，则手动实现私有数据的机制。

### 2. 共享数据相关

考虑和实现更普遍的共享数据同步方式，例如使用原子操作+让权等待。注意在实现中绕开中断/抢占机制。

当前已知，在vdso内部实现堆分配机制比较困难。因此，暂时绕过堆分配，使用静态分配的空间实现共享数据。虽然仍需考虑同步问题，但应该会简单一些？（例如环形缓冲区已知可以实现无锁MPMC（[高性能队列——Disruptor](https://tech.meituan.com/2016/11/18/disruptor.html)），我们的代码需要支持多生产者或多消费者吗？）

### 3. 与代码逻辑解耦

在内核态和用户态实现相似的、加载共享库的机制。实现根据需要，将内核的vdso库映射到用户态的机制。

### 4. 模块间依赖相关

将模块对外部的依赖尽量改为静态链接。对于无法修改的依赖，将模块与内核的通信机制改为内核修改模块的数据；将模块间的通信机制改为类似RPC。

### 5. vdso共享库实例

将内核的一个模块（如文件系统或网络）改造成vdso共享库，并验证其可以在内核态、在用户态被加载、被使用。

由于第4项的改造可能缺乏实例，考虑将第4步和第5步穿插进行。 -->

### 1. 对AsyncOS的修改

需要在用户态和内核态都具备加载共享库机制。

其包括：

- 调用库代码的机制（已实现）
- 访问类似共享库的私有数据（如：不共享的全局变量）的机制（未实现）
- 访问共享数据（vvar）的机制（已实现）
  - 共享数据是每个CPU一份还是所有CPU共用一份？目前的实现是per-CPU

### 2. 移植一个模块

需要进一步调研后确定步骤。

可能包括根据需求使用或实现一些共享数据结构，例如无锁队列。

#### 2.1. 多队列的共享调度器

#### 2.2. io_uring

##### 使用vdso共享库实现的内容

- 原本用mmap实现的提交队列（SQ）、完成队列（CQ）、实例数组（SQEs），可以实现为vdso共享库的共享数据。这会导致所有进程共享同一个上下文，队列从SPSC变为MPMC。
- 两个队列的入队出队操作
- 将入队出队操作封装为io_uring的操作：（用户态）提交请求、获取结果；（内核态）取出请求、放入结果；

###### 数据结构

下文中提到的队列均使用[此处](https://github.com/AsyncModules/vsched/blob/main/utils/src/deque.rs)的无锁环形缓冲区实现，支持MPMC和双端的`push`、`pop`。

`sq`的设计如下：

首先，无法沿用[原有的设计](https://gitee.com/LC_rosy/weekly-progress/blob/master/25.6.26~25.7.1/iouring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)，即在同一块环形缓冲区上使用`khead/ktail`、`sqe_head/sqe_tail`标识两个队列。因为当所有进程共享同一组队列时，某个用户进程完成`sqe`填写时，不能保证其它进程也完成了`sqe`的填写。因此，某个用户进程调用`submit`时，`sqe_head`和`sqe_tail`之间可能仍存在其它进程未填写完成的`sqe`，导致`submit`后内核读到未填写完成的数据。

因此，只保留了在用户和内核间共享的`sq`一个队列。用户需要提交请求时，先在自身的私有内存中创建一个`sqe`对象，填写完成后，调用队列的`push_back`方法，将该对象拷贝到共享内存中，`sq`队列的对应槽位中。内核的行为则与原有设计一致，均为`pop_front`获取`sqe`。

为了降低并发冲突，可以通过如下方式重新实现类似原设计的“暂存更改-批量提交”机制：在每个地址空间的私有内存中创建队列以代替`sqes`队列的功能，用户可以获取队列中元素的指针并填写队列中的元素（此时不需要拷贝）。填写完所有`sqe`后，将私有内存队列中的内容批量提交到共享内存的`sq`中（此时仍需拷贝）。为了实现该功能，需要实现队列的更多接口：

- **`push_slot`** ：将一个空元素加入队列，并返回其指针，使调用者可以更改该元素。其可以实现为：在`push`的基础上，省略填写数据和将槽位设置为`READY`的过程，使被`push`的槽位状态保留为`WRITING`；当返回的可变引用被释放时，再将状态设置为`READY`。
- **`push_multiple`** 和 **`pop_multiple`** ：批量`push`和`pop`。

`cq`的设计与`sq`类似。

###### 接口

`sq`的接口：

- **`SQE::new() -> SQE`** ：创建`SQE`。
  - `SQE`的字段可以直接更改
- **`SQ::push(sqe: SQE)`** ：将一个`SQE`提交到共享数据的`SQ`中。
- **`SQ::pop() -> SQE`** ：从共享数据的`SQ`中取出一个`SQE`。
- **`SQ::pop_multiple(max: isize) -> [SQE]`** :从共享数据的`SQ`中取出多个`SQE`。
- **`SQBuffer::get_sqe() -> SQERef`**：从私有数据的缓冲队列中取出一个`SQE`槽位供用户填写。
- **`SQBuffer::submit()`**： 将私有数据的缓冲队列中的所有`SQE`提交到共享数据的`SQ`中。

`cq`的接口与`sq`类似，包括`CQE::new`、`CQ::push`、`CQ::pop`、`CQ::pop_multiple()`、`CQBuffer::get_cqe`、`CQBuffer::submit`。

##### 在用户态实现的内容

- 统一io_uring的接口和一般I/O的接口，让io_uring对用户透明？

##### 在内核态实现的内容

- 各个I/O设备驱动与io_uring的机制对接

### 3. 提高框架易用性

- 使用宏等方式封装vdso开发过程中的常用操作。例如：内核或用户程序调用vdso函数；vdso共享库内部声明共享数据和私有数据。
  - 已实现的内容：通过vdso中的api.rs自动生成调用vdso模块的api、自动生成perCPU结构。
- 实现内核可按需映射vdso模块到用户态的机制，而不需每次加载应用程序都全部映射。
